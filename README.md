# Обход сгоревшего контроллера приборной панели (комбинации приборов) на Ford Focus 1

## История проблемы

Автомобиль Ford Focus 2003 года выпуска. В какой-то момент стрелка уровня топлива перестала работать. Могла остаться в нуле или уйти в за пределы полного бака (возможно, от вибрации).
Постоянно светился индикатор низкого уровня топлива (даже с полным баком). Датчик уровня топлива исправен: сопротивление между 8 и 15 контактами разъёма, идущего к приборной панели, было ожидаемым (ожидается для пустого бака - около 15 Ом, для полного бака - около 160 Ом).

В автосервисе сказали, что сгорел контроллер и надо менять приборную панель (они есть в продаже с разборок). Но непонятно, на сколько будут правильные показания, ведь приборная панель была откалибрована под другой экземпляр автомобиля. К тому же, просто поменять - это не так интересно :)

## Изучение

На приборной панели установлено 4 одинаковых шаговых двигателя, которые управляют стрелками температуры, скорости, тахометра и уровня топлива. Для управления шаговыми двигателями контроллер использует уровни от 0 до 5 вольт с использованием ШИМ (широтно-импульсной подуляции), что бы разделить шаги на микрошаги.

## Решение проблемы

1. Перерезал дорожки, идущие от контроллера к шаговому двигателю, управляющему стрелкой уровня топлива.
2. Подпаял к шаговому двигателю отладочную плату на драйвере TMC2209 (покупал на Озоне: https://www.ozon.ru/product/3-shtuki-mks-tmc2209-v3-0-drayver-shagovogo-dvigatelya-novaya-versiya-1368294229/ ).
3. Драйвером управляю с STM32F103C8T6 (использовал дешёвую отладочную плату).
4. Для определения уровня топлива завёл сигнал с разъёма с контакта 8 (идущего от датчика уровня топлива) на STM32 и определяю напряжение через встроенный АЦП.
5. Для управления светодидом, сигнализирующим о низком уровне топлива, так же была перерезана дорожка, идущая от контроллера к светодиоду, а к самому светодиоду подпаян провод и подключен к STM32.

## Софт микроконтроллера STM32

Исходники прошивки выложены в директории `firmware`. Так же там выложены и собранные бинарники.
Прошивка работает в следующей последовательности:
1. При включении питания начинает исполняться bootloader. Он настраивает UART на скорость 115200 бод и в течении трёх секунд ждёт внешние команды по UART. При этом, раз в секунду отправляет в UART строку " Ready".
2. Если внешних команд не было, то bootloader запускает основную программу.
3. Программа читает сохранённые настройки, настраивает UART-консоль (использует кодировку UTF-8) и начинает измерять напряжение с датчика топлива. В течении нескольких секунд стрелка не двигается, т.к. программа усредняет прочитанные значения. Далее значения с датчика топлива фильтруются, что бы стрелка лишний раз не дёргалась.

## UART-консоль

Консоль работает на скорости 115200 бод. Русские буквы передаются в кодировке UTF-8.
Основная задача консоли - это изменение калибровочных значений (переменных, в которых хранятся значения для пустого и полного бака). Так же консоль позволяет проводить отладку.
Список команд:

* `help` - показать список команд;
* `printenv` - показать список всех переменных и их значений;
* `setenv` - изменить значение переменной... например: `setenv adc_empty 750`. Переменные изменяются в оперативной памяти и после перезагрузки микроконтроллера эти изменения будут потеряны, если их не сохранить командой `saveevn`;
* `saveenv` - сохранить текущие значения всех переменных во флеш-память. При следующем запуске программа автоматически прочитает эти сохранённые значения;
* `loadenv` - загрузить ранее сохранённые значения всех переменных. Это и так происходит при каждом запуске;
* `delenv` - стереть все ранее сохранённые значения переменных. При следующей перезагрузке будут использоваться значения по умолчанию;
* `reset` - перезагрузить микроконтроллер;
* `get_adc` - показать текущее значение с датчика топлива. Это значение можно использовать для записи переменных `adc_*`;
* `set_adc` - подменить текущее значение датчика топлива на указанное в этой команде. Например: `set_adc 1000`. Имеет смысл только если ранее была вызвана команда `debug_adc 1`, в противном случае подменённое значение сразу же будет исправлено на настоящее, прочитанное с датчика топлива;
* `debug_adc` - если указать 1, то прекращает читать значения с датчика уровня топлива и позволяет подменять значения командой `set_adc`. Например: `debug_adc 1`;
* `debug_motor` - если указать 1, то прекращает автоматически двигать стрелки в зависимости от значения датчика уровня топлива, а вместо этого позволяет явно указать позицию стрелки командой `set_motor`. Например: `debug_motor 1`;
* `get_motor` - показывает позицию стрелки;
* `set_motor` - подменмит позицию стрелки на указанную. Имеет смысл только если ранее выполнялось `debug_motor 1`, иначе позиция сразу будет переписана на позицию, основанную на значении датчика уровня топлива. Например: `set_motor 300`;
* `adc_info` - показать последние 100 измеренных значений датчика уровня топлива, которые используются для фильтрации;
* `motor_info` - показать полную информацию о положении стрелки:
* `park` - уводит стрелку в крайнее левое положение. После этого она автоматически вернётся в правильное положение.

Список переменных:

* `adc_overempty` - минимальное значение, на которое реагирует стрелка. Если с датчика уровня топлива будет прочитано меньшее значение, то стрелка не будет на это реагировать (по умолчанию 400);
* `adc_empty` - значение с датчика уровня топлива, которое соответствует положению стрелки пустого бака (по умолчанию 800);
* `adc_full` - значение с датчика уровня топлива, которое соответствует положению стрелки полного бака (по умолчанию 4000);
* `adc_alert` - значение с датчика уровня топлива, при котором включается индикатор малого остатка топлива (по умолчанию 1470);
* `steps_empty` - количество шагов стрелки до отметки пустого бака (по умолчанию 200);
* `steps_full` - количество шагов стрелки до отметки полного бака (по умолчанию 1550);
* `steps_total` - максимальное количество шагов. Используется для возвращения стрелки в крайнее левое положение при включении или при команде `park` (по умолчанию 2000);
* `use_ema_filter` - если 0, то стрелка будет показывать последнее измеренное значение с датчика уровня топлива. Если 1, то стрелка будет показывать отфильтрованное значение (по умолчанию 1).

## Прошивка

Если в микроконтроллере уже есть bootloader, то для прошивки основной программы можно воспользоваться скриптом `flash_firmware.py`. Для этого необходимо выключить зажигание, запустить скрипт (например: `flash_firmware.py -p /dev/ttyUSB2 test.bin`). Скрипт будет ждать сообщений "Ready" от bootloader'а. При включении питания (повороте ключа зажигания на половину) начнёт исполняться bootloader и скрипт начнёт прошивку. После окончания прошивки скрипт перезагрузит микроконтроллер и обновлённая прошивка запустится.

Если в микроконтроллере нет bootloader, то придётся его записать любым удобным способом: например, через программатор ST-Link или через UART с предварительным переключением перемычки BOOT0.
